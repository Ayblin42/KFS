================================================================================
                         KFS 1 - EXPLICATION POUR DEBUTANTS
================================================================================

Ce document explique comment fonctionne le projet KFS (Kernel From Scratch) et
comment le compiler/lancer a 42 sans droits sudo.

================================================================================
                              TABLE DES MATIERES
================================================================================

1. C'est quoi ce projet ?
2. Comment compiler et lancer (a 42)
3. Structure des fichiers
4. Comment ca marche (le boot)
5. Explication de chaque fichier
6. Glossaire
7. Questions frequentes

================================================================================
                          1. C'EST QUOI CE PROJET ?
================================================================================

Le but est d'ecrire un KERNEL (noyau) minimaliste qui:
- Boot via GRUB (le bootloader)
- Affiche "42" a l'ecran

Un kernel, c'est le programme qui demarre en premier quand tu allumes un PC.
Il n'y a pas de systeme d'exploitation, pas de libc, pas de printf... RIEN.
Tu dois tout coder toi-meme.

C'EST QUOI UN KERNEL ?
----------------------

Imagine ton ordinateur comme une entreprise :

    +------------------------------------------+
    |           APPLICATIONS                   |  <- Les employes
    |   (Firefox, Word, Spotify, jeux...)      |     (font leur travail)
    +------------------------------------------+
                      |
                      v
    +------------------------------------------+
    |              KERNEL                      |  <- Le manager
    |   (Linux, Windows NT, notre KFS...)      |     (organise tout)
    +------------------------------------------+
                      |
                      v
    +------------------------------------------+
    |             MATERIEL                     |  <- Les outils
    |   (CPU, RAM, disque, ecran...)           |     (font le vrai travail)
    +------------------------------------------+

Le KERNEL (noyau) c'est le chef d'orchestre :
- Il decide qui utilise le CPU et quand
- Il gere la memoire (qui a droit a quoi)
- Il parle au materiel (ecran, clavier, disque...)
- Il protege les programmes les uns des autres

================================================================================
                  2. COMMENT COMPILER ET LANCER (A 42)
================================================================================

A 42, tu n'as PAS les droits sudo. Pas de probleme, on utilise DOCKER.

COMMANDES PRINCIPALES :
-----------------------

    make              Compile le kernel (via Docker)
    make iso          Cree l'ISO bootable
    make run          Compile + lance dans QEMU
    make verify       Verifie que le kernel est multiboot compliant
    make clean        Supprime les fichiers objets
    make fclean       Supprime tout (objets + binaires)
    make re           Recompile tout

PREMIERE UTILISATION :
----------------------

    1. Ouvre un terminal dans le dossier KFS
    2. Tape: make run
    3. Une fenetre QEMU s'ouvre avec "42" affiche
    4. Ferme QEMU avec Ctrl+C ou en fermant la fenetre

NOTE: La premiere fois, Docker build l'image (peut prendre 1-2 min).
      Les fois suivantes, c'est instantane.

POURQUOI DOCKER ?
-----------------

Pour compiler un kernel 32-bit, il faut des outils speciaux :
- gcc avec support 32-bit (gcc-multilib)
- Les outils GRUB (grub-pc-bin)
- etc.

Ces outils necessitent sudo pour s'installer. Docker permet d'avoir
un environnement complet SANS sudo.

Le Dockerfile installe tout ca dans un conteneur isole :
- Tu compiles DANS le conteneur
- Le resultat (kfs.bin, kfs.iso) sort dans ton dossier

================================================================================
                          3. STRUCTURE DES FICHIERS
================================================================================

KFS/
|-- Dockerfile          # Config Docker (environnement de compilation)
|-- Makefile            # Regles de compilation
|-- grub.cfg            # Configuration du bootloader GRUB
|-- linker.ld           # Script de linkage (organisation memoire)
|-- include/
|   |-- kernel.h        # Types de base (uint32_t, size_t...)
|   +-- vga.h           # Fonctions d'affichage ecran
+-- src/
    |-- boot.s          # Code assembleur de demarrage
    |-- kernel.c        # Point d'entree du kernel (kernel_main)
    +-- vga.c           # Code pour ecrire a l'ecran

FICHIERS GENERES :
------------------
obj/                    # Fichiers objets (.o)
iso/                    # Contenu de l'ISO
kfs.bin                 # Le kernel compile
kfs.iso                 # L'ISO bootable

================================================================================
                      4. COMMENT CA MARCHE (LE BOOT)
================================================================================

Quand tu lances "make run", voici ce qui se passe :

  +---------------------------------------------------------------------+
  |  1. QEMU demarre et simule un PC                                    |
  |                    |                                                |
  |                    v                                                |
  |  2. Le "BIOS" (simule) charge GRUB depuis l'ISO                     |
  |                    |                                                |
  |                    v                                                |
  |  3. GRUB lit grub.cfg et charge kfs.bin en memoire                  |
  |                    |                                                |
  |                    v                                                |
  |  4. GRUB verifie le "multiboot header" dans boot.s                  |
  |                    |                                                |
  |                    v                                                |
  |  5. GRUB saute a _start (dans boot.s)                               |
  |                    |                                                |
  |                    v                                                |
  |  6. boot.s initialise la stack et appelle kernel_main()             |
  |                    |                                                |
  |                    v                                                |
  |  7. kernel_main() initialise l'ecran VGA et affiche "42"            |
  |                    |                                                |
  |                    v                                                |
  |  8. Le kernel entre en boucle infinie (hlt)                         |
  +---------------------------------------------------------------------+

C'EST QUOI MULTIBOOT ?
----------------------

Multiboot est un "contrat" standard entre GRUB et le kernel.

Notre kernel doit avoir un "header multiboot" au debut pour que GRUB
le reconnaisse. C'est comme un badge d'entree :

    "Salut GRUB ! Je suis un kernel valide, tu peux me charger !"

Le nombre magique 0x1BADB002 est le mot de passe.

================================================================================
                      5. EXPLICATION DE CHAQUE FICHIER
================================================================================

------------------------------------------------------------------------------
                              src/boot.s
------------------------------------------------------------------------------

Premier code execute. Ecrit en assembleur GNU AS (syntaxe AT&T).

PARTIE 1 - HEADER MULTIBOOT (lignes 1-13) :
    .set MAGIC,    0x1BADB002       <- Nombre magique multiboot
    .set FLAGS,    ALIGN | MEMINFO  <- Options demandees
    .set CHECKSUM, -(MAGIC + FLAGS) <- Verification (somme = 0)

PARTIE 2 - STACK (lignes 15-20) :
    stack_bottom:
    .skip 16384                     <- Reserve 16 KB pour la pile
    stack_top:

    La STACK (pile) stocke les variables locales et adresses de retour.

PARTIE 3 - POINT D'ENTREE (lignes 22-33) :
    _start:
        mov $stack_top, %esp        <- Configure le pointeur de pile
        call kernel_main            <- Appelle notre code C
        cli                         <- Desactive les interruptions
    1:  hlt                         <- Met le CPU en pause
        jmp 1b                      <- Boucle infinie

------------------------------------------------------------------------------
                              src/kernel.c
------------------------------------------------------------------------------

Le coeur du kernel. Tres simple pour l'instant :

    void kernel_main(void)
    {
        terminal_initialize();        // Efface l'ecran
        terminal_writestring("42");   // Affiche "42"

        while (1)
            __asm__ volatile ("hlt"); // Dort pour toujours
    }

Et strlen() car on n'a pas la libc :

    size_t strlen(const char *str)
    {
        size_t len = 0;
        while (str[len])
            len++;
        return len;
    }

------------------------------------------------------------------------------
                              src/vga.c
------------------------------------------------------------------------------

Code pour afficher du texte via le mode VGA texte.

COMMENT CA MARCHE :
    L'ecran en mode texte = grille 80x25 caracteres.
    Chaque case = 2 octets en memoire a l'adresse 0xB8000 :
        - Octet 1 : caractere ASCII
        - Octet 2 : couleur (foreground + background)

    Exemple : 'A' en gris sur noir = 0x0741
        - 0x41 = 'A' en ASCII
        - 0x07 = gris clair (7) sur noir (0)

FONCTIONS :
    terminal_initialize()   - Efface l'ecran (remplit de ' ')
    terminal_putchar(c)     - Affiche un caractere a la position courante
    terminal_writestring(s) - Affiche une chaine complete

------------------------------------------------------------------------------
                              include/kernel.h
------------------------------------------------------------------------------

Types de base (on n'a pas <stdint.h>) :

    typedef unsigned char      uint8_t;   // 1 octet  (0-255)
    typedef unsigned short     uint16_t;  // 2 octets (0-65535)
    typedef unsigned int       uint32_t;  // 4 octets (0-4 milliards)
    typedef uint32_t           size_t;    // Taille

------------------------------------------------------------------------------
                              include/vga.h
------------------------------------------------------------------------------

Constantes et prototypes VGA :

    #define VGA_WIDTH   80        // 80 colonnes
    #define VGA_HEIGHT  25        // 25 lignes
    #define VGA_MEMORY  0xB8000   // Adresse du buffer video

------------------------------------------------------------------------------
                              linker.ld
------------------------------------------------------------------------------

Script pour le linker. Dit comment organiser le kernel en memoire.

    ENTRY(_start)           <- Point d'entree
    . = 2M;                 <- Charge le kernel a 2 MB

    SECTIONS {
        .text   { ... }     <- Code executable
        .rodata { ... }     <- Donnees read-only (strings)
        .data   { ... }     <- Donnees initialisees
        .bss    { ... }     <- Donnees non-initialisees (stack)
    }

POURQUOI 2 MB ?
    Les premiers 1 MB sont reserves (BIOS, VGA, ROM).
    On met le kernel apres pour eviter les conflits.

------------------------------------------------------------------------------
                              grub.cfg
------------------------------------------------------------------------------

Configuration GRUB :

    set timeout=5                         <- Attend 5 sec
    set default=0                         <- Boot la 1ere entree

    menuentry "KFS - Kernel From Scratch" {
        multiboot /boot/kfs.bin           <- Charge le kernel
        boot                              <- Lance
    }

------------------------------------------------------------------------------
                              Dockerfile
------------------------------------------------------------------------------

Image Docker avec les outils :
    - gcc-multilib  : GCC avec support 32-bit
    - nasm          : Assembleur (optionnel)
    - grub-pc-bin   : Outils GRUB
    - xorriso       : Creation d'ISO
    - qemu          : Emulateur

------------------------------------------------------------------------------
                              Makefile
------------------------------------------------------------------------------

COMPILATION (ce qui se passe dans Docker) :
    1. as --32 boot.s -> obj/boot.o        (assembleur)
    2. gcc -m32 *.c -> obj/*.o             (compilateur C)
    3. ld -m elf_i386 ... -> kfs.bin       (linker)

CREATION ISO :
    1. Copie kfs.bin dans iso/boot/
    2. Copie grub.cfg dans iso/boot/grub/
    3. grub-mkrescue cree kfs.iso

FLAGS IMPORTANTS :
    -m32                : Compile en 32-bit
    -ffreestanding      : Pas de libc
    -fno-builtin        : Pas de fonctions builtin
    -fno-stack-protector: Pas de protection stack
    -nostdlib           : Pas de lib standard
    -nodefaultlibs      : Pas de libs par defaut

================================================================================
                              6. GLOSSAIRE
================================================================================

BIOS
    Programme dans la carte mere qui demarre le PC.

BOOTLOADER (GRUB)
    Programme qui charge le kernel en memoire.

MULTIBOOT
    Standard de communication bootloader <-> kernel.

KERNEL
    Le coeur du systeme. Premier programme apres le bootloader.

VGA
    Mode video texte 80x25 a l'adresse 0xB8000.

FREESTANDING
    Environnement sans OS ni libc. Le kernel EST le systeme.

LINKER
    Combine les fichiers .o en un executable.

QEMU
    Emulateur qui simule un PC complet.

DOCKER
    Conteneur avec un environnement isole. Pas besoin de sudo.

CROSS-COMPILATION
    Compiler POUR une autre architecture.
    Ici : on compile SUR x86_64 Linux, POUR i386 bare-metal.
    On utilise gcc -m32 (plus simple qu'un vrai cross-compiler).

================================================================================
                         7. QUESTIONS FREQUENTES
================================================================================

Q: Pourquoi "42" ?
R: Reference au "Guide du voyageur galactique" + nom de l'ecole !

Q: Pourquoi le kernel boucle a la fin ?
R: Il n'a nulle part ou retourner. S'il "retournait", il crasherait.

Q: C'est quoi hlt ?
R: "Halt" = pause. Le CPU attend la prochaine interruption.
   Mieux que boucler a vide (economise l'energie).

Q: Pourquoi cli (desactiver les interruptions) ?
R: On n'a pas encore de gestionnaire d'interruptions.
   Si une interruption arrive, le CPU ne saura pas quoi faire = crash.

Q: Pourquoi Docker et pas installer directement ?
R: A 42, pas de sudo. Docker permet d'avoir les outils sans droits root.

Q: C'est quoi la difference entre ISO et IMG ?
R: ISO = image CD-ROM (utilisee ici)
   IMG = image disque dur
   Les deux sont bootables, ISO est plus simple.

Q: Je peux ajouter des fonctionnalit√©s ?
R: Oui ! C'est les bonus / projets suivants :
   - Support du clavier
   - Couleurs
   - Printf/printk
   - Scroll
   - Multi-ecrans

================================================================================
                              POUR ALLER PLUS LOIN
================================================================================

OSDev Wiki : https://wiki.osdev.org
    LA reference pour le developpement OS.

Projets KFS suivants :
    KFS2 : GDT, IDT, interruptions
    KFS3 : Memoire, pagination
    KFS4 : Processus

================================================================================
                   FELICITATIONS ! TU AS COMPRIS LES BASES !
================================================================================

Ce n'est que le debut. Un kernel complet = millions de lignes.
Mais chaque kernel a commence comme ca : un "Hello World".

Le tien affiche "42". C'est deja enorme.

================================================================================
